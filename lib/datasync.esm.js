
/*!
 * ============================================================
 *  Project:   datasync.js
 *  Version:   1.0.0
 *  Homepage:  https://github.com/lamlib/datasync
 *
 *  Description:
 *    Datasync giúp bạn xử lý đồng bộ dữ liệu giữa máy chủ và client.
 *
 *  Author:    Nhat Han <lamlib2023@gmail.com>
 *  License:   MIT License
 *  Copyright: © 2025 Nhat Han
 *
 *  Created:   2025-05-26
 * ============================================================
 */
var P=new Map,w=new Map,m=0,u={onQueueEmpty:null,onQueueAdd:null},d={error:null,success:null},S=()=>!!d.error,U=({onQueueAdd:n,onQueueEmpty:r})=>{n&&r?(u.onQueueAdd=n,u.onQueueEmpty=r):console.warn("\u26A0\uFE0F DataSync: Missing loading hooks. Use setLoadingHooks() to register.")},y=(n,r)=>{if(!w.has(n))return!1;let t=w.get(n);return t.length!==r.length?!1:t.every((a,s)=>a===r[s])},p=async(n,r,t)=>{d.error=null,d.success=null;try{if(t){if(y(r,t)){console.warn("\u26A0\uFE0F DataSync: Using cached data, skipping request.");return}w.set(r,t)}let s=setTimeout(()=>{m++,u.onQueueAdd&&u.onQueueAdd()},600);P.set(r,null);let o=await n();clearTimeout(s);let e=await o.json();if(i.after&&i.after(e),e.code&&e.code!=="SUCCESS"||e.result===!1||!o.ok)throw new Error(e.message);let c=e.data||e.result;return P.set(r,c),e.message&&(d.success=e.message),c}catch(a){d.error=a,console.log(a)}finally{m>0&&m--,m===0&&u.onQueueEmpty&&u.onQueueEmpty()}},g={},i={before:null,after:null},h=(n,r={})=>{let t=n,a={...r},s=n.match(/:(\w+)/g);return s&&s.forEach(o=>{let e=o.substring(1);a[e]!==void 0&&(t=t.replace(o,a[e]),delete a[e])}),{finalUrl:t,remainingParams:a}},b=(n,r,t)=>{Object.defineProperty(g,n,{value:async a=>await p(async()=>{let s=new Headers;i.before&&await i.before({params:a,headers:s,type:"GET"});let{finalUrl:o,remainingParams:e}=h(r,a),c=new URLSearchParams(e),l=c.toString()?"?"+c.toString():"";return await fetch(o+l,{headers:s})},n,t==="no-cache"?!1:Object.values(a||{})),writable:!1})},E=(n,r)=>{Object.defineProperty(g,n,{value:async(t,a)=>await p(async()=>{let s=new Headers;i.before&&await i.before({body:t,params:a,headers:s,type:"POST"});let{finalUrl:o,remainingParams:e}=h(r,a),c=new URLSearchParams(e),l=c.toString()?"?"+c.toString():"",f=o+l;return t instanceof FormData?await fetch(f,{method:"POST",body:t,headers:s}):(s.append("Accept","application/json"),s.append("Content-Type","application/json"),fetch(f,{method:"POST",body:JSON.stringify(t),headers:s}))},n,!1),writable:!1})},T=(n,r)=>{Object.defineProperty(g,n,{value:async(t,a)=>await p(async()=>{let{finalUrl:s,remainingParams:o}=h(r,a),e=new Headers;i.before&&await i.before({body:t,params:a,headers:e,type:"PATCH"});let c=new URLSearchParams(o),l=c.toString()?"?"+c.toString():"",f=s+l;return t instanceof FormData?await fetch(f,{method:"PATCH",body:t,headers:e}):(e.append("Accept","application/json"),e.append("Content-Type","application/json"),fetch(f,{method:"PATCH",body:JSON.stringify(t),headers:e}))},n,!1),writable:!1})},j=(n,r)=>{Object.defineProperty(g,n,{value:async t=>await p(async()=>{let{finalUrl:a,remainingParams:s}=h(r,t),o=new Headers;i.before&&await i.before({params:t,headers:o,type:"DELETE"});let e=new URLSearchParams(s),c=e.toString()?"?"+e.toString():"",l=a+c;return await fetch(l,{method:"DELETE",headers:o})},n,!1),writable:!1})},H=(n,r)=>{Object.defineProperty(g,n,{value:async(t,a)=>await p(async()=>{let{finalUrl:s,remainingParams:o}=h(r,a),e=new Headers;i.before&&await i.before({body:t,params:a,headers:e,type:"PUT"});let c=new URLSearchParams(o),l=c.toString()?"?"+c.toString():"",f=s+l;return t instanceof FormData?await fetch(f,{method:"PUT",body:t,headers:e}):(e.append("Accept","application/json"),e.append("Content-Type","application/json"),fetch(f,{method:"PUT",body:JSON.stringify(t),headers:e}))},n,!1),writable:!1})};export{P as dataStore,S as hasError,i as interceptors,u as loadingHooks,d as messageState,w as paramCache,j as registerDeleteEndpoint,b as registerGetEndpoint,T as registerPatchEndpoint,E as registerPostEndpoint,H as registerPutEndpoint,g as requestHandlers,U as setLoadingHooks};
